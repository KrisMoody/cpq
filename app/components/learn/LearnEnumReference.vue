<script setup lang="ts">
interface EnumDefinition {
  name: string
  domain: string
  values: {
    value: string
    description: string
  }[]
}

const enums: EnumDefinition[] = [
  {
    name: 'ProductType',
    domain: 'Product',
    values: [
      { value: 'STANDALONE', description: 'Sold as-is, no configuration needed' },
      { value: 'BUNDLE', description: 'Has features and options requiring configuration' },
    ],
  },
  {
    name: 'BillingFrequency',
    domain: 'Product',
    values: [
      { value: 'ONE_TIME', description: 'Single purchase, not recurring' },
      { value: 'MONTHLY', description: 'Billed every month' },
      { value: 'QUARTERLY', description: 'Billed every 3 months' },
      { value: 'ANNUAL', description: 'Billed once per year' },
      { value: 'CUSTOM', description: 'Custom billing period (specify months)' },
    ],
  },
  {
    name: 'QuoteStatus',
    domain: 'Quote',
    values: [
      { value: 'DRAFT', description: 'Being edited, not yet submitted' },
      { value: 'PENDING', description: 'Submitted for review' },
      { value: 'PENDING_APPROVAL', description: 'Awaiting manager approval' },
      { value: 'APPROVED', description: 'Approved by manager' },
      { value: 'REJECTED', description: 'Rejected by manager' },
      { value: 'ACCEPTED', description: 'Customer accepted the quote' },
      { value: 'FINALIZED', description: 'Quote completed and locked' },
      { value: 'CANCELLED', description: 'Quote cancelled and voided' },
    ],
  },
  {
    name: 'DiscountType',
    domain: 'Discount',
    values: [
      { value: 'PERCENTAGE', description: 'Discount as percent of price (e.g., 10% off)' },
      { value: 'FIXED_AMOUNT', description: 'Fixed dollar reduction (e.g., $50 off)' },
    ],
  },
  {
    name: 'DiscountScope',
    domain: 'Discount',
    values: [
      { value: 'LINE_ITEM', description: 'Applies to a single product line' },
      { value: 'QUOTE', description: 'Applies to entire order total' },
      { value: 'PRODUCT_CATEGORY', description: 'Applies to all products in a category' },
    ],
  },
  {
    name: 'ContractStatus',
    domain: 'Contract',
    values: [
      { value: 'DRAFT', description: 'Being negotiated, not yet active' },
      { value: 'ACTIVE', description: 'In effect, pricing applies to quotes' },
      { value: 'EXPIRED', description: 'Past end date, no longer applies' },
    ],
  },
  {
    name: 'AttributeType',
    domain: 'Attribute',
    values: [
      { value: 'TEXT', description: 'Free-form text string' },
      { value: 'NUMBER', description: 'Numeric value with optional min/max' },
      { value: 'BOOLEAN', description: 'True/false toggle' },
      { value: 'SELECT', description: 'Dropdown from predefined options' },
      { value: 'DATE', description: 'Calendar date value' },
    ],
  },
  {
    name: 'RuleType',
    domain: 'Rules',
    values: [
      { value: 'CONFIGURATION', description: 'Validates product combinations and dependencies' },
      { value: 'PRICING', description: 'Adjusts prices or triggers approvals' },
    ],
  },
  {
    name: 'RuleTrigger',
    domain: 'Rules',
    values: [
      { value: 'ON_PRODUCT_ADD', description: 'Fires when product is added to quote' },
      { value: 'ON_QUANTITY_CHANGE', description: 'Fires when line item quantity changes' },
      { value: 'ON_QUOTE_SAVE', description: 'Fires when quote is saved' },
      { value: 'ON_FINALIZE', description: 'Fires when quote is finalized' },
    ],
  },
  {
    name: 'AffinityType',
    domain: 'Guided Selling',
    values: [
      { value: 'CROSS_SELL', description: 'Complementary product ("Also consider...")' },
      { value: 'UPSELL', description: 'Premium alternative ("Upgrade to...")' },
      { value: 'ACCESSORY', description: 'Add-on item ("Don\'t forget...")' },
      { value: 'REQUIRED', description: 'Mandatory companion ("You\'ll also need...")' },
      { value: 'FREQUENTLY_BOUGHT', description: 'Popular combination ("Often bought together")' },
      { value: 'SUBSCRIPTION_ADDON', description: 'Recurring add-on service' },
    ],
  },
  {
    name: 'QuestionType',
    domain: 'Guided Selling',
    values: [
      { value: 'SINGLE_CHOICE', description: 'Pick exactly one option' },
      { value: 'MULTIPLE_CHOICE', description: 'Pick one or more options' },
      { value: 'RANGE', description: 'Select from a range (e.g., budget)' },
      { value: 'YES_NO', description: 'Binary yes/no question' },
    ],
  },
  {
    name: 'RecommendationSource',
    domain: 'Guided Selling',
    values: [
      { value: 'RULE_BASED', description: 'Generated from affinity rules' },
      { value: 'AI_GENERATED', description: 'Generated by ML model' },
      { value: 'QUESTIONNAIRE', description: 'From needs assessment survey' },
      { value: 'MANUAL', description: 'Entered by sales rep' },
    ],
  },
  {
    name: 'RecommendationAction',
    domain: 'Guided Selling',
    values: [
      { value: 'SHOWN', description: 'Displayed to user' },
      { value: 'ACCEPTED', description: 'User added product to quote' },
      { value: 'DISMISSED', description: 'User declined recommendation' },
    ],
  },
  {
    name: 'TierType',
    domain: 'Pricing',
    values: [
      { value: 'UNIT_PRICE', description: 'Price per unit at this tier level' },
      { value: 'FLAT_PRICE', description: 'Flat price for entire quantity range' },
    ],
  },
]

const searchQuery = ref('')
const expandedDomains = ref<string[]>([])

const domains = computed(() => {
  const domainMap = new Map<string, EnumDefinition[]>()
  for (const e of enums) {
    const existing = domainMap.get(e.domain) || []
    existing.push(e)
    domainMap.set(e.domain, existing)
  }
  return Array.from(domainMap.entries()).map(([name, items]) => ({ name, items }))
})

const filteredEnums = computed(() => {
  if (!searchQuery.value.trim()) return enums

  const query = searchQuery.value.toLowerCase()
  return enums.filter(
    e =>
      e.name.toLowerCase().includes(query)
      || e.values.some(v => v.value.toLowerCase().includes(query) || v.description.toLowerCase().includes(query)),
  )
})

function toggleDomain(domain: string) {
  const index = expandedDomains.value.indexOf(domain)
  if (index === -1) {
    expandedDomains.value.push(domain)
  }
  else {
    expandedDomains.value.splice(index, 1)
  }
}

function isValueHighlighted(value: string, description: string): boolean {
  if (!searchQuery.value.trim()) return false
  const query = searchQuery.value.toLowerCase()
  return value.toLowerCase().includes(query) || description.toLowerCase().includes(query)
}
</script>

<template>
  <div class="space-y-4">
    <div class="flex flex-col sm:flex-row sm:items-center gap-3 sm:gap-4">
      <UInput
        v-model="searchQuery"
        placeholder="Search enums or values..."
        icon="i-heroicons-magnifying-glass"
        class="w-full sm:w-64"
      />
      <span class="text-sm text-ga-gray-600">
        {{ filteredEnums.length }} of {{ enums.length }} enums
      </span>
    </div>

    <div class="space-y-3">
      <div
        v-for="domain in domains"
        :key="domain.name"
        class="border border-ga-gray-300 rounded-lg overflow-hidden"
      >
        <button
          class="w-full flex items-center justify-between p-3 hover:bg-ga-gray-200 transition-colors cursor-pointer"
          @click="toggleDomain(domain.name)"
        >
          <span class="font-medium">{{ domain.name }}</span>
          <div class="flex items-center gap-2">
            <span class="text-sm text-ga-gray-600">{{ domain.items.length }} enums</span>
            <UIcon
              :name="expandedDomains.includes(domain.name) ? 'i-heroicons-chevron-up' : 'i-heroicons-chevron-down'"
              class="w-4 h-4 text-ga-gray-500"
            />
          </div>
        </button>

        <div
          class="grid transition-[grid-template-rows] duration-300"
          :class="expandedDomains.includes(domain.name) || searchQuery.trim() ? 'grid-rows-[1fr]' : 'grid-rows-[0fr]'"
        >
          <div class="overflow-hidden">
            <div class="p-3 pt-0 space-y-3 border-t border-ga-gray-300">
              <div
                v-for="e in domain.items.filter(item => filteredEnums.includes(item))"
                :key="e.name"
                class="bg-ga-gray-100 rounded-lg p-3"
              >
                <h4 class="font-mono text-sm font-medium text-ga-navy-600 mb-2">
                  {{ e.name }}
                </h4>
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-2">
                  <div
                    v-for="v in e.values"
                    :key="v.value"
                    class="flex items-start gap-2 text-sm"
                    :class="isValueHighlighted(v.value, v.description) ? 'bg-yellow-100 -mx-1 px-1 rounded' : ''"
                  >
                    <code class="font-mono text-xs bg-ga-gray-300 px-1.5 py-0.5 rounded flex-shrink-0">
                      {{ v.value }}
                    </code>
                    <span class="text-ga-gray-700 text-xs">{{ v.description }}</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>
